HOW TO LEARN SDL3 BY BUILDING PONG - A SELF-DISCOVERY GUIDE
==========================================================

YOUR PONG COMPLEXITY ANALYSIS:
-----------------------------
You're right to question the complexity. Pong is deceptively simple but teaches you:
- Game loop architecture
- Real-time input handling  
- Basic physics (collision + reflection)
- State management
- Coordinate systems
- Timing and frame rates

Complexity: Beginner-Intermediate. Perfect for learning!

SDL2 vs SDL3 DIFFERENCES:
-------------------------
SDL3 is cleaner but function signatures changed. Key differences:
- SDL_CreateWindow: No position params in SDL3
- SDL_CreateRenderer: Simpler in SDL3
- SDL_FRect vs SDL_Rect: SDL3 prefers floats
- Event names: Some constants renamed

For learning, SDL3 is better - fewer gotchas.

YOUR COLLISION THEORY:
---------------------
Your reflection physics is correct! For wall collisions:
- Hit top/bottom wall: dy = -dy  (vertical flip)
- Hit paddle: dx = -dx  (horizontal flip)

For paddle collision detection, you're on the right track:
- Check if ball.x <= paddle_width OR ball.x >= screen_width - paddle_width
- Then check if ball.y is between paddle.y and paddle.y + paddle.height

LEARNING STRATEGY - NO HAND-HOLDING:
====================================

PHASE 1: SDL3 EXPLORATION (Week 1)
-----------------------------------
1. Open C:/msys64/ucrt64/include/SDL3/SDL.h
2. Read the file structure - see how functions are organized
3. Look at these specific headers:
   - SDL_video.h (window functions)
   - SDL_render.h (drawing functions)  
   - SDL_events.h (input functions)
   - SDL_keyboard.h (keyboard functions)

PHASE 2: MINIMAL EXPERIMENTS (Week 1-2)
---------------------------------------
For each function you discover:
1. Write a tiny test program
2. Print the return values
3. Try different parameters
4. Document what you learned

Start with:
- SDL_Init variations
- Window creation flags
- Renderer creation options
- Event types

PHASE 3: COORDINATE SYSTEM MASTERY (Week 2)
-------------------------------------------
Create experiments to understand:
1. Screen coordinate system (0,0 at top-left)
2. How SDL_FRect works (x, y, w, h)
3. Screen boundaries for your window size
4. Relationship between logical and physical pixels

PHASE 4: INPUT DISCOVERY (Week 2-3)
-----------------------------------
Explore keyboard handling:
1. What events fire when you press/release keys?
2. What's the difference between SDL_EVENT_KEY_DOWN and SDL_EVENT_KEY_UP?
3. How to check which key was pressed?
4. How to handle multiple keys at once?

PHASE 5: ANIMATION PRINCIPLES (Week 3)
-------------------------------------
Discover frame rate control:
1. What happens without SDL_Delay?
2. What's the right delay for 60 FPS?
3. How to make movement speed frame-rate independent?
4. Experiment with different delay values

PHASE 6: COLLISION DETECTION (Week 3-4)
--------------------------------------
Build collision experiments:
1. Create a bouncing square first
2. Detect screen edges
3. Implement your reflection physics
4. Add a stationary paddle
5. Make ball bounce off paddle

PHASE 7: GAME STATE MANAGEMENT (Week 4)
-------------------------------------
Design your state system:
1. Ball position, velocity
2. Paddle positions
3. Scores
4. Game states (playing, paused, game over)

DISCOVERY TECHNIQUES:
===================

FUNCTION SIGNATURE DISCOVERY:
----------------------------
1. Let your IDE show you function signatures
2. Look at return types carefully
3. Notice which functions take pointers vs values
4. Pay attention to const qualifiers

ERROR HANDLING PATTERN:
---------------------
Every SDL function follows this pattern:
- Returns pointer? Check for NULL
- Returns int? Usually 0 = success, negative = error
- Always call SDL_GetError() after failure

EXPERIMENTAL DEBUGGING:
----------------------
```c
// Your debugging template:
printf("Function returned: %d\n", result);
printf("Error: %s\n", SDL_GetError());
printf("Window created at: %p\n", window);
```

HEADERS TO EXPLORE IN ORDER:
===========================

1. SDL.h - Overview and version info
2. SDL_video.h - Window management
3. SDL_render.h - 2D graphics
4. SDL_events.h - Event system
5. SDL_keyboard.h - Keyboard input
6. SDL_timer.h - Timing functions
7. SDL_rect.h - Rectangle utilities

COMMON SDL3 CONSTANTS TO DISCOVER:
=================================
- Window flags (SDL_WINDOW_*)
- Event types (SDL_EVENT_*)
- Key codes (SDLK_*)
- Color values (0-255 range)

SELF-CHALLENGE EXERCISES:
========================

EXERCISE 1: Window Explorer
Create a program that:
- Creates a window
- Prints its size
- Changes its title every second
- Reports when it's moved/resized

EXERCISE 2: Input Logger
Create a program that:
- Logs every key press/release
- Shows key codes and names
- Tracks how long keys are held
- Handles multiple simultaneous keys

EXERCISE 3: Physics Sandbox
Create a program that:
- Has a bouncing ball
- Shows ball coordinates on screen
- Lets you change ball speed with keys
- Displays collision detection visually

EXERCISE 4: Performance Tester
Create a program that:
- Measures frame rate
- Tests different delay values
- Shows CPU usage
- Compares different rendering methods

LEARNING MINDSET:
================

DON'T:
- Copy-paste code
- Skip understanding function signatures
- Rush to the "final solution"
- Get frustrated by errors (they teach you)

DO:
- Read headers directly
- Write tiny test programs
- Document your discoveries
- Celebrate small victories
- Take breaks when stuck

PONG IMPLEMENTATION ROADMAP:
===========================

WEEK 1-2: Foundation
- Working window
- Basic input handling
- Simple drawing

WEEK 3: Game Objects
- Paddle movement
- Ball physics
- Collision detection

WEEK 4: Game Logic
- Scoring system
- Game states
- Win/lose conditions

WEEK 5: Polish
- Smooth animations
- Better controls
- Visual improvements

Remember: The goal isn't to finish quickly - it's to understand deeply. Every error message, every crash, every misbehaving pixel is teaching you something valuable.

When you get stuck, ask specific questions about what you discovered, not for general solutions. The struggle is where the learning happens.